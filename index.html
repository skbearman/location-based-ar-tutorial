<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>20M radius</title>

<!-- A-Frame -->
<script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>

<!-- AR.js with GPS (RELIABLE CDN) -->
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.7/three.js/build/ar-threex-location-only.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.7/aframe/build/aframe-ar.js"></script>

<style>
body {
  margin: 0;
  overflow: hidden;
  font-family: system-ui, sans-serif;
}

/* PLACE BUTTON */
#ui {
  position: fixed;
  bottom: 1rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.35);
  padding: 0.6rem 0.9rem;
  border-radius: 999px;
  z-index: 9999;
  backdrop-filter: blur(6px);
}

#place-btn {
  padding: 0.85rem 1.5rem;
  border-radius: 999px;
  border: none;
  font-size: 1.05rem;
  font-weight: 600;
  background: #111;
  color: #fff;
}

#place-btn:disabled {
  background: #555;
  opacity: 0.7;
}

/* TOOLBAR */
#transform-ui {
  position: fixed;
  top: 0.5rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.45);
  color: #fff;
  padding: 0.6rem 0.75rem;
  border-radius: 12px;
  backdrop-filter: blur(6px);
  z-index: 9999;
  display: none;
}

#transform-ui h4 {
  margin: 0 0 0.4rem 0;
  text-align: center;
  font-size: 0.9rem;
}

#transform-ui .row {
  display: flex;
  justify-content: center;
  gap: 0.35rem;
  margin-bottom: 0.3rem;
}

#transform-ui button {
  width: 48px;
  height: 48px;
  border-radius: 8px;
  border: none;
  font-size: 1.05rem;
  background: rgba(255,255,255,0.2);
  color: #fff;
}

#lock-btn {
  width: auto;
  padding: 0.45rem 1.1rem;
  background: #ff6b6b;
  font-weight: 600;
  font-size: 0.95rem;
}

/* DEBUG OVERLAY */
#debug {
  position: fixed;
  left: 0.5rem;
  bottom: 0.5rem;
  z-index: 9999;
  background: rgba(0,0,0,0.6);
  color: #0f0;
  padding: 0.4rem 0.6rem;
  border-radius: 6px;
  font-size: 0.7rem;
  max-width: 60vw;
  white-space: pre-line;
}
</style>
</head>

<body>

<div id="ui">
  <button id="place-btn" disabled>Getting GPS…</button>
</div>

<div id="transform-ui">
  <h4>Adjust Bench</h4>

  <div class="row">
    <button id="move-up">↑</button>
  </div>

  <div class="row">
    <button id="move-left">←</button>
    <button id="move-down">↓</button>
    <button id="move-right">→</button>
  </div>

  <div class="row">
    <button id="height-up">Y+</button>
    <button id="height-down">Y-</button>
  </div>

  <div class="row">
    <button id="rot-left">↺</button>
    <button id="rot-right">↻</button>
  </div>

  <div class="row">
    <button id="lock-btn">Lock</button>
  </div>
</div>

<div id="debug">GPS: waiting…</div>

<a-scene
 embedded
 vr-mode-ui="enabled:false"
 arjs="sourceType:webcam; debugUIEnabled:true"
 renderer="antialias:true; alpha:true">

  <!-- GPS camera -->
  <a-camera gps-new-camera="gpsMinDistance:1; positionMinAccuracy:100"></a-camera>

</a-scene>

<script>
const THREE      = AFRAME.THREE;

const scene      = document.querySelector('a-scene');
const camera     = document.querySelector('[gps-new-camera]');
const placeBtn   = document.getElementById('place-btn');
const toolbar    = document.getElementById('transform-ui');
const lockBtn    = document.getElementById('lock-btn');
const debugEl    = document.getElementById('debug');

const moveUp     = document.getElementById('move-up');
const moveDown   = document.getElementById('move-down');
const moveLeft   = document.getElementById('move-left');
const moveRight  = document.getElementById('move-right');

const heightUp   = document.getElementById('height-up');
const heightDown = document.getElementById('height-down');

const rotLeft    = document.getElementById('rot-left');
const rotRight   = document.getElementById('rot-right');

let lastCoords   = null;
let activeBench  = null;
let benchCoords  = null;
let benchLocked  = false;

/* Haversine distance in meters */
function haversine(lat1, lon1, lat2, lon2){
  const R = 6378137;
  const dLat = THREE.MathUtils.degToRad(lat2 - lat1);
  const dLon = THREE.MathUtils.degToRad(lon2 - lon1);
  const a =
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(THREE.MathUtils.degToRad(lat1)) *
    Math.cos(THREE.MathUtils.degToRad(lat2)) *
    Math.sin(dLon/2) * Math.sin(dLon/2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/* Update debug overlay */
function updateDebug(){
  let text = '';
  if (!lastCoords){
    text = 'GPS: waiting…';
  } else {
    text = `You:
lat ${lastCoords.latitude.toFixed(6)}
lon ${lastCoords.longitude.toFixed(6)}`;
    if (benchCoords){
      const d = haversine(
        lastCoords.latitude, lastCoords.longitude,
        benchCoords.latitude, benchCoords.longitude
      );
      text += `

Bench:
lat ${benchCoords.latitude.toFixed(6)}
lon ${benchCoords.longitude.toFixed(6)}
dist ~ ${d.toFixed(1)} m`;

      if (activeBench) {
        const s = activeBench.getAttribute('scale');
        if (s && typeof s.x === 'number') {
          text += `
scale ~ ${s.x.toFixed(2)}`;
        }
        const vis = activeBench.getAttribute('visible');
        text += `
visible: ${vis}`;
      }
    }
  }
  debugEl.textContent = text;
}

/* Scale + show/hide bench based on GPS distance */
function updateBenchScale(){
  if (!lastCoords || !benchCoords || !activeBench) return;

  const d = haversine(
    lastCoords.latitude, lastCoords.longitude,
    benchCoords.latitude, benchCoords.longitude
  );

  const MAX_VISIBLE_DIST = 20;  // meters

  // If farther than 20m, hide bench completely
  if (d > MAX_VISIBLE_DIST) {
    activeBench.setAttribute('visible', 'false');
    updateDebug();
    return;
  }

  // Within 20m → visible
  activeBench.setAttribute('visible', 'true');

  // Tunable parameters for scaling
  const NEAR = 3;                // meters or closer → full size
  const FAR  = MAX_VISIBLE_DIST; // scale down as you approach 20m

  // Normalized 0–1 based on distance in [NEAR, FAR]
  const t = THREE.MathUtils.clamp((d - NEAR) / (FAR - NEAR), 0, 1);

  // Lerp between 1.0 (near) and 0.2 (far)
  // For stronger effect, you can change to (1.5, 0.05, t)
  const scaleVal = THREE.MathUtils.lerp(1.0, 0.2, t);

  // A-Frame attribute
  activeBench.setAttribute('scale', `${scaleVal} ${scaleVal} ${scaleVal}`);

  // Force on underlying three.js object as well
  if (activeBench.object3D) {
    activeBench.object3D.scale.set(scaleVal, scaleVal, scaleVal);
  }

  // Update debug to reflect new scale / visibility
  updateDebug();
}

/* GPS READY - listen on window (AR.js dispatches here) */
window.addEventListener('gps-camera-update-position', e => {
  const pos = e.detail && e.detail.position;
  if (!pos) return;

  lastCoords = {
    latitude:  pos.latitude,
    longitude: pos.longitude
  };

  placeBtn.disabled = false;
  placeBtn.textContent = "Place Bench Ahead";

  updateBenchScale();
});

/* PLACE BENCH WITH 3m GPS OFFSET */
placeBtn.onclick = () => {
  if (!lastCoords) return;

  // Camera forward direction
  const forward = new THREE.Vector3();
  camera.object3D.getWorldDirection(forward);
  forward.y = 0;
  forward.normalize();

  // Bearing in radians
  const bearingRad = Math.atan2(forward.x, forward.z);

  // Offset 3 m ahead
  const distance = 3;
  const R = 6378137;

  const lat1 = THREE.MathUtils.degToRad(lastCoords.latitude);
  const lon1 = THREE.MathUtils.degToRad(lastCoords.longitude);
  const angDist = distance / R;

  const lat2 = Math.asin(
    Math.sin(lat1) * Math.cos(angDist) +
    Math.cos(lat1) * Math.sin(angDist) * Math.cos(bearingRad)
  );

  const lon2 = lon1 + Math.atan2(
    Math.sin(bearingRad) * Math.sin(angDist) * Math.cos(lat1),
    Math.cos(angDist) - Math.sin(lat1) * Math.sin(lat2)
  );

  const benchLat = THREE.MathUtils.radToDeg(lat2);
  const benchLon = THREE.MathUtils.radToDeg(lon2);

  benchCoords = { latitude: benchLat, longitude: benchLon };

  const bench = document.createElement('a-entity');
  bench.setAttribute('gltf-model','assets/park_bench.glb');
  bench.setAttribute(
    'gps-new-entity-place',
    `latitude:${benchLat}; longitude:${benchLon}`
  );
  // Slightly larger initial scale so it's easier to see
  bench.setAttribute('scale','2 2 2');
  bench.setAttribute('position','0 0 0');

  const yawDeg = THREE.MathUtils.radToDeg(bearingRad);
  bench.setAttribute('rotation', `0 ${yawDeg} 0`);

  // When the model loads, re-center its mesh so origin is at the model center
  bench.addEventListener('model-loaded', () => {
    const obj = bench.getObject3D('mesh');
    if (!obj) return;

    const box = new THREE.Box3().setFromObject(obj);
    const center = box.getCenter(new THREE.Vector3());

    // Shift the mesh so its center is at (0,0,0) of the entity
    obj.position.sub(center);
  });

  scene.appendChild(bench);

  activeBench = bench;
  benchLocked = false;
  lockBtn.textContent = "Lock";
  toolbar.style.display = "block";

  updateBenchScale();
};

/* HELPERS */
function getPos(){ return activeBench?.getAttribute('position'); }
function getRot(){ return activeBench?.getAttribute('rotation'); }

function setPos(p){ activeBench?.setAttribute('position', p); }
function setRot(r){ activeBench?.setAttribute('rotation', r); }

const MOVE_STEP   = 5;
const HEIGHT_STEP = 5;
const ROT_STEP    = 15;

/* RELATIVE MOVE */
function move(fwd, side){
  if (!activeBench || benchLocked) return;

  const p = {...getPos()};

  const fwdVec = new THREE.Vector3();
  camera.object3D.getWorldDirection(fwdVec);
  fwdVec.y = 0;
  fwdVec.normalize();

  const right = new THREE.Vector3(fwdVec.z, 0, -fwdVec.x);

  p.x += (fwdVec.x * fwd + right.x * side) * MOVE_STEP;
  p.z += (fwdVec.z * fwd + right.z * side) * MOVE_STEP;

  setPos(p);
}

/* BUTTON EVENTS */
moveUp.onclick    = ()=>move( 1,  0);
moveDown.onclick  = ()=>move(-1,  0);
moveLeft.onclick  = ()=>move( 0, -1);
moveRight.onclick = ()=>move( 0,  1);

heightUp.onclick = ()=>{
  if (!activeBench || benchLocked) return;
  const p = {...getPos()};
  p.y += HEIGHT_STEP;
  setPos(p);
};

heightDown.onclick = ()=>{
  if (!activeBench || benchLocked) return;
  const p = {...getPos()};
  p.y -= HEIGHT_STEP;
  setPos(p);
};

rotLeft.onclick = ()=>{
  if (!activeBench || benchLocked) return;
  const r = {...getRot()};
  r.y -= ROT_STEP;
  setRot(r);
};

rotRight.onclick = ()=>{
  if (!activeBench || benchLocked) return;
  const r = {...getRot()};
  r.y += ROT_STEP;
  setRot(r);
};

/* LOCK TOOLBAR (only locks transforms, not scaling/visibility) */
lockBtn.onclick = ()=>{
  if (!activeBench) return;

  benchLocked = !benchLocked;
  lockBtn.textContent = benchLocked ? "Unlock" : "Lock";

  // Optional: hide toolbar when locked
  toolbar.style.display = benchLocked ? "none" : "block";
};
</script>

</body>
</html>
